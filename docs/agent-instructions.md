# Agent Instructions — Wisteria

Rules and context for AI agents working on this project.
Read this before making any changes.

---

## Project Context

Wisteria is a Japanese figurine e-commerce store. The owner (Cassie) is a
strong TypeScript/Next.js developer learning Python/FastAPI as she builds this.

**Always explain Python/FastAPI idioms and patterns when using them.**
Don't just write the code — teach why it's done that way, especially for:
- SQLAlchemy patterns (relationships, queries, session management)
- FastAPI dependency injection
- Pydantic model/schema patterns
- Python async patterns
- Alembic migration workflow

TypeScript/Next.js/React patterns don't need explanation unless unusual.

---

## Architecture Rules

### Backend (Python / FastAPI)
- **Async everywhere.** All routes are `async def`. All DB queries use
  `await`. Never use sync SQLAlchemy methods.
- **Service layer pattern.** Routes handle HTTP concerns (parsing request,
  returning response). Business logic lives in `app/services/`. Routes call
  services, services call the DB.
- **Pydantic schemas for all request/response bodies.** Never return raw
  SQLAlchemy models from routes. Always convert to a Pydantic schema.
  This controls exactly what fields are exposed.
- **Dependency injection for cross-cutting concerns.** DB sessions via
  `Depends(get_db)`. Auth via `Depends(get_current_admin)`. Never
  import the session directly in a route.
- **Money is always integer cents.** `price_cents: int`. Never `price: float`.
  No exceptions.
- **UUIDs for all primary keys.** Use `uuid.uuid4()` as default, never
  auto-increment integers.
- **Slugs for public-facing lookups.** Products are fetched by slug in public
  routes (`/products/{slug}`) and by UUID in admin routes
  (`/admin/products/{id}`).

### Frontend (TypeScript / Next.js)
- **TypeScript strict mode.** No `any` types. No `// @ts-ignore`.
- **Named exports only.** No `export default`.
- **Server Components by default.** Only add `"use client"` when the component
  needs state, event handlers, or browser APIs.
- **API calls go through `src/lib/api.ts`.** Never call `fetch()` directly
  in components. The `api<T>()` wrapper handles base URL, headers, and errors.
- **Types live in `src/types/index.ts`.** Shared across the app. Must mirror
  backend Pydantic schemas.
- **Functional components only.** No class components.
- **Tailwind for all styling.** No CSS modules, no styled-components.

### Database
- **Alembic for all schema changes.** Never modify the DB manually.
  Always: change model → `alembic revision --autogenerate` → review
  generated migration → `alembic upgrade head`.
- **Review autogenerated migrations before running them.** Alembic sometimes
  generates unnecessary or incorrect operations. Always read the migration file.

---

## File Organization

### Backend
```
backend/app/
  config.py          — Settings singleton (pydantic-settings)
  database.py        — Engine, session factory, get_db dependency
  main.py            — FastAPI app, middleware, router registration
  dependencies.py    — Shared dependencies (auth, etc.)
  models/            — SQLAlchemy models (one file per table)
  schemas/           — Pydantic request/response schemas
  routers/           — Route handlers (thin — delegate to services)
  services/          — Business logic (one file per domain)
  utils/             — Helpers (JWT, hashing, email templates)
```

### Frontend
```
frontend/src/
  app/               — Next.js App Router pages and layouts
  components/
    ui/              — Generic primitives (Button, Card, Input, Badge)
    layout/          — Header, Footer, MobileNav
    product/         — ProductCard, ProductGrid, ProductImage
    cart/            — CartDrawer, CartItem, CartSummary
    order/           — OrderDetail, OrderStatusBadge
  lib/               — API client, utils, constants
  hooks/             — Custom React hooks
  stores/            — Zustand stores
  types/             — TypeScript interfaces
```

---

## Coding Standards

### Python
- Format/lint with Ruff (replaces Black + isort + flake8)
- Type check with mypy (strict mode)
- Use `collections.abc` imports (not `typing`) for `AsyncGenerator`, `Sequence`, etc.
- Docstrings for public functions (Google style)
- f-strings over `.format()` or `%`

### TypeScript
- ESLint (configured by create-next-app)
- Interfaces for public APIs, types for internal models
- `async/await` over promise chains
- Descriptive variable names (no single-letter vars except loop indices)

### Both
- Comments only when logic isn't self-evident
- Conventional commits: `feat:`, `fix:`, `chore:`, `docs:`
- Components/modules under 300 lines; extract when they grow

---

## How to Run

```bash
# Full stack via Docker
docker compose -f docker/docker-compose.yml up

# Backend only (needs local Postgres)
cd backend
pip install -r requirements.txt
uvicorn app.main:app --reload

# Frontend only
cd frontend
npm install
npm run dev

# Migrations
cd backend
alembic revision --autogenerate -m "description"
alembic upgrade head

# Tests
cd backend && pytest
cd frontend && npm test
```

---

## Documentation Maintenance

**Docs must stay current.** Outdated docs are worse than no docs. Update
documentation during or after each phase — don't leave it as a "later" task.

### After completing each phase, update:

1. **`docs/todo.md`** — Check off completed items. Add any new tasks that
   were discovered during implementation. Remove items that turned out to be
   unnecessary.

2. **`docs/phase-N-takeaways.md`** — Create a new takeaways file for the
   phase you just completed (e.g., `phase-1-takeaways.md`). Include:
   - What was built (file-level summary)
   - New patterns introduced and how they work
   - Gotchas encountered and how they were solved
   - Anything that deviated from the original plan and why

3. **`docs/decisions/`** — Add a new ADR file (`NNN-short-title.md`) if you
   made a significant technical decision that wasn't already documented.
   Add it to the index table in `docs/decisions/README.md`. If an existing
   ADR turned out to be wrong and you changed course, update its status to
   "Revised" and explain what changed.

4. **`docs/agent-instructions.md`** (this file) — Update if:
   - New architecture rules emerged from implementation
   - File organization changed (new directories, renamed files)
   - New pitfalls were discovered
   - Phase-specific instructions need corrections based on what actually happened

5. **`CLAUDE.md`** — Update if:
   - A new docs file was created (add it to the Documentation section)
   - Key rules changed
   - Quick start commands changed

### During a phase:
- If you discover something that contradicts the docs, fix the docs immediately.
  Don't wait until the phase is done.
- If you add a new pattern or convention, document it before moving on to
  the next task in the phase.

---

## Phase-Specific Instructions

### Phase 1: Backend Foundation
- Create `app/models/base.py` with a `Base` class that has `id` (UUID),
  `created_at`, `updated_at` columns. All models inherit from this.
- Product model goes in `app/models/product.py`. Use SQLAlchemy `Enum` type
  for condition and category.
- AdminUser model goes in `app/models/admin_user.py`.
- After creating models, update `alembic/env.py` to import Base and set
  `target_metadata = Base.metadata`.
- The health endpoint should attempt a simple query (`SELECT 1`) to verify
  the DB connection is alive.
- Test the full Docker stack: `docker compose up` → hit health → see DB
  connected.

### Phase 2: Product CRUD + Auth
- Pydantic schemas should use `model_config = ConfigDict(from_attributes=True)`
  to enable creating schemas from SQLAlchemy model instances.
- Product service methods should accept `AsyncSession` as their first argument
  (passed from the route via dependency injection).
- JWT: use `python-jose` with HS256. Token payload: `{"sub": admin_user.id, "exp": ...}`.
- The seed script should be a standalone Python script (`backend/scripts/seed.py`)
  that can be run with `python -m scripts.seed`.
- Include edge case tests: duplicate slugs, buying unavailable products,
  invalid JWT, expired JWT.

### Phase 3: Frontend Product Display
- Use Server Components for product listing and detail pages.
  Call the backend API directly (server-side fetch, no CORS needed).
- Build small, composable UI primitives first. Don't skip this step.
- ProductCard: image, name, price (formatted from cents), condition badge.
- Mobile-first responsive design. Use Tailwind breakpoints (`sm:`, `md:`, `lg:`).

### Phase 4: Cart
- Zustand store with `persist` middleware targets localStorage.
- Cart items are Product objects. Since these are resale items (usually qty=1),
  adding a duplicate should show a toast, not increment quantity.
- The cart icon in the header should show item count as a badge.
- CartDrawer slides out from the right side of the screen.

### Phase 5: Checkout + Stripe
- **Critical:** The Stripe webhook endpoint must read the raw request body
  for signature verification. FastAPI parses JSON by default — use
  `Request.body()` to get raw bytes before any parsing.
- Create Order + OrderItems in the webhook handler, NOT in the checkout
  endpoint. The checkout endpoint only creates a Stripe session.
- After order creation, mark all purchased products as `is_available = False`.
- Send confirmation email via Resend in the webhook handler.
- Test locally with `stripe listen --forward-to localhost:8000/api/v1/webhooks/stripe`.

### Phase 6: Admin Panel
- JWT stored in memory (Zustand store, NOT localStorage — avoids XSS).
- Admin layout: sidebar with nav links, main content area.
- Auth guard: if no valid JWT, redirect to /admin/login.
- Product soft-delete: set `is_available = False`, don't actually DELETE.
- Order status updates: dropdown with pending → paid → shipped → cancelled.

### Phase 7: Polish + Deploy
- error.tsx at the app root and in key route segments.
- Loading skeletons that match the actual content layout (not generic spinners).
- Vercel: set `NEXT_PUBLIC_API_URL` to the Railway backend URL.
- Railway: set all env vars from `.env.example`, use Railway's managed Postgres.
- Production Stripe webhook URL: `https://your-railway-url/api/v1/webhooks/stripe`.

---

## Common Pitfalls to Avoid

1. **Don't return SQLAlchemy models directly from routes.** Always convert to
   Pydantic schemas. SQLAlchemy models have lazy-loaded relationships that
   break serialization.

2. **Don't forget `await` on async DB operations.** SQLAlchemy async will
   silently return a coroutine object instead of results if you forget `await`.

3. **Don't parse the Stripe webhook body as JSON before verifying the signature.**
   The signature is computed over the raw bytes. If you parse + re-serialize,
   the bytes change and verification fails.

4. **Don't use `float` for money anywhere.** Not in Python, not in TypeScript,
   not in the database. Always integer cents.

5. **Don't commit Alembic migrations without reviewing them.** Autogenerate
   is a suggestion, not gospel. It sometimes drops columns it shouldn't or
   creates redundant indexes.

6. **Don't use `git add .` or `git add -A`.** Always add specific files.
   The `.env` files contain secrets.

7. **Don't install frontend dependencies (Zustand, etc.) until the phase
   that needs them.** Keeps the working tree clean and focused.
