# Agent Instructions — Wisteria

Rules and context for AI agents working on this project.
Read this before making any changes.

For phase-specific implementation details and known pitfalls, see
[`phase-playbook.md`](phase-playbook.md).

---

## Project Context

Wisteria is a Japanese figurine e-commerce store. The owner (Cassie) is a
strong TypeScript/Next.js developer learning Python/FastAPI as she builds this.

**Always explain Python/FastAPI idioms and patterns when using them.**
Don't just write the code — teach why it's done that way, especially for:

- SQLAlchemy patterns (relationships, queries, session management)
- FastAPI dependency injection
- Pydantic model/schema patterns
- Python async patterns
- Alembic migration workflow

TypeScript/Next.js/React patterns don't need explanation unless unusual.

---

## Architecture Rules

### Backend (Python / FastAPI)

- **Async everywhere.** All routes are `async def`. All DB queries use
  `await`. Never use sync SQLAlchemy methods.
- **Service layer pattern.** Routes handle HTTP concerns (parsing request,
  returning response). Business logic lives in `app/services/`. Routes call
  services, services call the DB.
- **Pydantic schemas for all request/response bodies.** Never return raw
  SQLAlchemy models from routes. Always convert to a Pydantic schema.
  This controls exactly what fields are exposed.
- **Dependency injection for cross-cutting concerns.** DB sessions via
  `Depends(get_db)`. Auth via `Depends(get_current_admin)`. Never
  import the session directly in a route.
- **Money is always integer cents.** `price_cents: int`. Never `price: float`.
  No exceptions.
- **UUIDs for all primary keys.** Use `uuid.uuid4()` as default, never
  auto-increment integers.
- **Slugs for public-facing lookups.** Products are fetched by slug in public
  routes (`/products/{slug}`) and by UUID in admin routes
  (`/admin/products/{id}`).

### Frontend (TypeScript / Next.js)

- **TypeScript strict mode.** No `any` types. No `// @ts-ignore`.
- **Named exports only.** No `export default`.
- **Server Components by default.** Only add `"use client"` when the component
  needs state, event handlers, or browser APIs.
- **API calls go through `src/lib/api.ts`.** Never call `fetch()` directly
  in components. The `api<T>()` wrapper handles base URL, headers, and errors.
- **Types live in `src/types/index.ts`.** Shared across the app. Must mirror
  backend Pydantic schemas.
- **Functional components only.** No class components.
- **Tailwind for all styling.** No CSS modules, no styled-components.

### Database

- **Alembic for all schema changes.** Never modify the DB manually.
  Always: change model → `alembic revision --autogenerate` → review
  generated migration → `alembic upgrade head`.
- **Review autogenerated migrations before running them.** Alembic sometimes
  generates unnecessary or incorrect operations. Always read the migration file.

---

## File Organization

### Backend

```
backend/app/
  config.py          — Settings singleton (pydantic-settings)
  database.py        — Engine, session factory, get_db dependency
  main.py            — FastAPI app, middleware, router registration
  dependencies.py    — Shared dependencies (auth, etc.)
  models/            — SQLAlchemy models (one file per table)
  schemas/           — Pydantic request/response schemas
  routers/           — Route handlers (thin — delegate to services)
  services/          — Business logic (one file per domain)
  utils/             — Helpers (JWT, hashing, email templates)
```

### Frontend

```
frontend/src/
  app/               — Next.js App Router pages and layouts
  components/
    ui/              — Generic primitives (Button, Card, Input, Badge)
    layout/          — Header, Footer, MobileNav
    product/         — ProductCard, ProductGrid, ProductImage
    cart/            — CartDrawer, CartItem, CartSummary
    order/           — OrderDetail, OrderStatusBadge
  lib/               — API client, utils, constants
  hooks/             — Custom React hooks
  stores/            — Zustand stores
  types/             — TypeScript interfaces
```

---

## Coding Standards

### Python

- Format/lint with Ruff (replaces Black + isort + flake8)
- Type check with mypy (strict mode)
- Use `collections.abc` imports (not `typing`) for `AsyncGenerator`, `Sequence`, etc.
- Docstrings for public functions (Google style)
- f-strings over `.format()` or `%`

### TypeScript

- ESLint (configured by create-next-app)
- Interfaces for public APIs, types for internal models
- `async/await` over promise chains
- Descriptive variable names (no single-letter vars except loop indices)

### Both

- Comments only when logic isn't self-evident
- Conventional commits: `feat:`, `fix:`, `chore:`, `docs:`
- Components/modules under 300 lines; extract when they grow

---

## How to Run

```bash
# Full stack via Docker
docker compose -f docker/docker-compose.yml up

# Backend only (needs local Postgres)
cd backend
pip install -r requirements.txt
uvicorn app.main:app --reload

# Frontend only
cd frontend
npm install
npm run dev

# Migrations
cd backend
alembic revision --autogenerate -m "description"
alembic upgrade head

# Tests (inside Docker — no local venv)
docker compose -f docker/docker-compose.yml exec backend pytest tests/ -v

# Tests create `wisteria_test` DB automatically on first run.
# Dev data in `wisteria` is never touched.

# Frontend tests (E2E with Playwright)
cd frontend
npm run test:e2e          # Headless mode, runs against running Docker stack
npm run test:e2e:ui       # Interactive UI mode (shows browsers, allows debugging)
npm run test:e2e:headed   # Headed mode (shows browser windows as tests run)

# Playwright configuration:
# - baseURL: http://localhost:3000
# - Test files in: frontend/tests/e2e/*.spec.ts
# - Runs against all 3 browsers: Chromium, Firefox, WebKit
# - Screenshots and videos on failure, traces on retry
```

---

## Testing Strategy

### Dedicated Test Database

Tests run against `wisteria_test`, NOT the dev `wisteria` database. See ADR 010.

- `conftest.py` auto-creates `wisteria_test` on first run (no manual setup).
- TRUNCATE between tests for isolation — safe because it's a throwaway DB.
- Dev seed data is never affected by test runs.

### TDD Workflow (Phase 3+)

We use Red-Green-Refactor for backend services and API routes. See ADR 011.

**For each new backend feature:**

1. Write Pydantic schemas (request/response shapes)
2. Write failing test cases for the service function
3. Implement the service until tests pass
4. Write failing test cases for the route
5. Implement the route, wire up the service
6. Refactor while tests stay green

**TDD applies to:** service functions, API route behavior, auth flows.
**TDD does NOT apply to:** models (declarative), scripts, config, frontend styling.

**Testing principles:**

- Test behavior, not implementation details.
- Use real DB calls (against `wisteria_test`), not mocks.
- No arbitrary coverage targets — cover critical paths and edge cases.

---

## Documentation Checklist

**Docs must stay current.** Update during or after each phase, not "later."

After completing a phase, update:

- [ ] `docs/todo.md` — check off items, add discovered tasks
- [ ] `docs/phase-N-takeaways.md` — create for the completed phase
- [ ] `docs/decisions/` — add ADR if a significant decision was made
- [ ] This file — if architecture rules or file org changed
- [ ] `CLAUDE.md` — if key rules or commands changed

If you discover something that contradicts the docs mid-phase, fix it immediately.
